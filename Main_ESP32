/**
 * @file main_esp32.c
 * @author KB2RWW (adapted for ESP32)
 * @date 2025-12-21
 * @brief Main function for CW Beacon programmable via serial port on ESP32
 */
/*
ESP32 Pin Assignments for CW Beacon:
Used I/O Pins:
- GPIO 25: PWM output for CW tone (connect to speaker/amplifier)
- GPIO 33: Inverted PWM output for CW tone (complementary to GPIO 25)
- GPIO 26: Keying output (high when CW tone is active, for transmitter enable)
- GPIO 27: Inverted keying output (low when CW tone is active, high when inactive)
- GPIO 1 (TX): UART transmit (serial output to computer)
- GPIO 3 (RX): UART receive (serial input from computer)
Power: 3.3V, GND
*/
#include <Arduino.h>
#include <Preferences.h>
#include <string.h>

// Preferences for saving settings
Preferences prefs;

// Global message
String message = "CQ CQ CQ KB2RWW beacken FN21US reply to kb2rww@gmail.com";

// PWM for tone
#define PWM_RESOLUTION 8  // 8-bit resolution
#define PWM_FREQ 800      // Initial frequency

// Pins
#define TONE_PIN 25
#define INV_TONE_PIN 33
#define KEY_PIN 26
#define INV_KEY_PIN 27

// Macros for CW tone
#define CW_TONE_ON() \
    do { \
        ledcWrite(TONE_PIN, 128); \
        ledcWrite(INV_TONE_PIN, 127); \
        digitalWrite(KEY_PIN, HIGH); \
        digitalWrite(INV_KEY_PIN, LOW); \
    } while (0)  // PWM on complementary, key high, inv key low
#define CW_TONE_OFF() \
    do { \
        ledcWrite(TONE_PIN, 0); \
        ledcWrite(INV_TONE_PIN, 0); \
        digitalWrite(KEY_PIN, LOW); \
        digitalWrite(INV_KEY_PIN, HIGH); \
    } while (0)  // PWM off, key low, inv key high

// Adjustable parameters
unsigned int tone_freq = 800;
unsigned int dot_time = 100;
unsigned int dash_time = 300;
unsigned int symbol_space = 100;
unsigned int char_space = 300;
unsigned int word_space = 700;

// Named constants
const unsigned int MAX_MESSAGE_LENGTH = 64;
const unsigned int MIN_WPM = 5;
const unsigned int MAX_WPM = 25;
const unsigned int DOT_TIME_BASE = 1200;
const unsigned int TONE_DURATION = 10000; // 10 seconds
const unsigned int SILENT_PAUSE = 5000; // 10 seconds

// Morse code patterns (0 = dot, 1 = dash)
const char* morse_code[41] = {
    "01",       // A .-
    "1000",     // B -...
    "1010",     // C -.-.
    "100",      // D -..
    "0",        // E .
    "0010",     // F ..-.
    "110",      // G --.
    "0000",     // H ....
    "00",       // I ..
    "0111",     // J .---
    "101",      // K -.-
    "0100",     // L .-..
    "11",       // M --
    "10",       // N -.
    "111",      // O ---
    "0110",     // P .--.
    "1101",     // Q --.-
    "010",      // R .-.
    "000",      // S ...
    "1",        // T -
    "001",      // U ..-
    "0001",     // V ...-
    "011",      // W .--
    "1001",     // X -..-
    "1011",     // Y -.--
    "1100",     // Z --..
    "11111",    // 0 -----
    "01111",    // 1 .----
    "00111",    // 2 ..---
    "00011",    // 3 ...--
    "00001",    // 4 ....-
    "00000",    // 5 .....
    "10000",    // 6 -....
    "11000",    // 7 --...
    "11100",    // 8 ---..
    "11110",    // 9 ----.
    "010101",   // . .-.-.-
    "110011",   // , --..--
    "001100",   // ? ..--..
    "10010",    // / -..-.
    "011010",   // @ .--.-.
};

void init_pwm(void) {
    // Configure PWM
    ledcAttach(TONE_PIN, tone_freq, PWM_RESOLUTION);
    ledcWrite(TONE_PIN, 0);  // Start off
    ledcAttach(INV_TONE_PIN, tone_freq, PWM_RESOLUTION);
    ledcWrite(INV_TONE_PIN, 0);  // Start off
    // Set keying pins as outputs
    pinMode(KEY_PIN, OUTPUT);
    pinMode(INV_KEY_PIN, OUTPUT);
    digitalWrite(KEY_PIN, LOW);
    digitalWrite(INV_KEY_PIN, HIGH);
}

void init_serial(void) {
    Serial.begin(115200);
}

void load_settings(void) {
    prefs.begin("cw_beacon", false);
    message = prefs.getString("message", "CQCQCQ  KB2RWW  beacken  FN21us  reply  to  kb2rww@gmail.com");
    tone_freq = prefs.getUInt("tone_freq", 800);
    dot_time = prefs.getUInt("dot_time", 100);
    dash_time = dot_time * 3;
    symbol_space = dot_time;
    char_space = dot_time * 3;
    word_space = dot_time * 7;
    ledcWriteTone(TONE_PIN, tone_freq);
    ledcWriteTone(INV_TONE_PIN, tone_freq);
    prefs.end();
}

void send_string(const String& str) {
    Serial.print(str);
}

void parse_command(const String& command) {
    if (command == "H" || command == "?") {
        // Send menu
        send_string("CW Beacon Menu:\r\n");
        send_string("MSG:<message> - Set CW message (up to 64 char)\r\n");
        send_string("FREQ:<freq> - Set tone frequency in Hz\r\n");
        send_string("SPEED:<wpm> - Set CW speed in WPM (5-25)\r\n");
        send_string("H or ? - Show this menu\r\n");
    } else if (command.startsWith("MSG:")) {
        // Set message
        String new_message = command.substring(4);
        if (new_message.length() < MAX_MESSAGE_LENGTH) {
            message = new_message;
            prefs.begin("cw_beacon", false);
            prefs.putString("message", message);
            prefs.end();
            send_string("Message set to: ");
            send_string(message);
            send_string("\r\n");
        } else {
            send_string("Error: Message too long. Maximum 63 characters.\r\n");
        }
    } else if (command.startsWith("FREQ:")) {
        // Set frequency
        unsigned int freq = command.substring(5).toInt();
        if (freq > 0) {
            tone_freq = freq;
            ledcWriteTone(TONE_PIN, tone_freq);        // Update frequency
            ledcWriteTone(INV_TONE_PIN, tone_freq);    // Update frequency for inv
            prefs.begin("cw_beacon", false);
            prefs.putUInt("tone_freq", tone_freq);
            prefs.end();
            send_string("Frequency set to: ");
            send_string(String(tone_freq));
            send_string(" Hz\r\n");
        } else {
            send_string("Error: Invalid frequency. Must be a positive integer.\r\n");
        }
    } else if (command.startsWith("SPEED:")) {
        // Set CW speed in WPM
        unsigned int wpm = command.substring(6).toInt();
        if (wpm >= MIN_WPM && wpm <= MAX_WPM) {
            dot_time = DOT_TIME_BASE / wpm;
            dash_time = dot_time * 3;
            symbol_space = dot_time;
            char_space = dot_time * 3;
            word_space = dot_time * 7;
            prefs.begin("cw_beacon", false);
            prefs.putUInt("dot_time", dot_time);
            prefs.end();
            send_string("Speed set to: ");
            send_string(String(wpm));
            send_string(" WPM\r\n");
        } else {
            send_string("Error: Invalid WPM. Use 5-25.\r\n");
        }
    } else {
        send_string("Error: Unknown command. Type H or ? for help.\r\n");
    }
}

void check_serial() {
    static String temp_message;
    static int j = 0;

    while (Serial.available() && j < MAX_MESSAGE_LENGTH - 1) {
        char received_char = Serial.read();
        if (received_char == '\r' || received_char == '\n') {
            parse_command(temp_message);
            temp_message = "";
            j = 0;
            break;
        } else {
            temp_message += received_char;
            j++;
        }
    }
}

void play_symbol(char symbol) {
    if (symbol == '0') {  // Dot
        CW_TONE_ON();
        delay(dot_time);
        CW_TONE_OFF();
    } else if (symbol == '1') {  // Dash
        CW_TONE_ON();
        delay(dash_time);
        CW_TONE_OFF();
    }
}

void play_morse(char letter) {
    if (letter >= 'A' && letter <= 'Z') {
        const char* code = morse_code[letter - 'A'];
        while (*code) {
            play_symbol(*code);
            delay(symbol_space);
            code++;
        }
    } else if (letter >= 'a' && letter <= 'z') {
        const char* code = morse_code[letter - 'a'];
        while (*code) {
            play_symbol(*code);
            delay(symbol_space);
            code++;
        }
    } else if (letter == ' ') {
        delay(word_space);
        return;
    } else if (letter >= '0' && letter <= '9') {
        const char* code = morse_code[26 + (letter - '0')];
        while (*code) {
            play_symbol(*code);
            delay(symbol_space);
            code++;
        }
    } else if (letter == '.') {
        const char* code = morse_code[36]; // . .-.-.-
        while (*code) {
            play_symbol(*code);
            delay(symbol_space);
            code++;
        }
    } else if (letter == ',') {
        const char* code = morse_code[37]; // , --..--
        while (*code) {
            play_symbol(*code);
            delay(symbol_space);
            code++;
        }
    } else if (letter == '?') {
        const char* code = morse_code[38]; // ? ..--..
        while (*code) {
            play_symbol(*code);
            delay(symbol_space);
            code++;
        }
    } else if (letter == '/') {
        const char* code = morse_code[39]; // / -..-.
        while (*code) {
            play_symbol(*code);
            delay(symbol_space);
            code++;
        }
    } else if (letter == '@') {
        const char* code = morse_code[40]; // @ .--.-.
        while (*code) {
            play_symbol(*code);
            delay(symbol_space);
            code++;
        }
    }
    delay(char_space);
}
void setup() {
    init_pwm();
    init_serial();
    load_settings();
    CW_TONE_OFF();  // Start with tone off and key low, inv key high
}

void loop() {
    check_serial();

    // Play the current message
    for (int i = 0; i < message.length(); i++) {
        play_morse(message[i]);
    }

    // Continuous tone for 1/2 minute between cycles, checking serial
    CW_TONE_ON();
    unsigned long tone_start = millis();
    while (millis() - tone_start < TONE_DURATION) {
        check_serial();
        delay(100);  // Poll every 100ms
    }
    CW_TONE_OFF();
    delay(SILENT_PAUSE);  // 30 second silent pause after continuous tone
}
